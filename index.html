<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vocabulary MVP v4.2 — Standalone</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* 控制 details 展開/收合符號 */
      details summary span::before {
        content: "＋";
      }
      details[open] summary span::before {
        content: "−";
      }
    </style>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gradient-to-b from-indigo-50 to-white min-h-screen">
    <style>
      details summary .icon-plus { display: inline-block; }
      details[open] summary .icon-plus { display: none; }
      details summary .icon-minus { display: none; }
      details[open] summary .icon-minus { display: inline-block; }
      details summary .icon-plus,
      details summary .icon-minus {
        display: flex;
        align-items: center;
        justify-content: center;
      }
    </style>
    <div id="root"></div>
    <script type="text/babel" data-presets="env,react,typescript">
      window.onerror = function(msg, src, line, col, err) {
        const div = document.createElement('div');
        div.style.background = '#b91c1c';
        div.style.color = '#fff';
        div.style.padding = '12px';
        div.style.fontFamily = 'monospace';
        div.textContent = `Error: ${msg} (line ${line}, column ${col})`;
        document.body.prepend(div);
      };

      const { useEffect, useMemo, useRef, useState } = React;

      const useHashRoute = () => {
        const [hash, setHash] = useState(() => window.location.hash || "#/");
        useEffect(() => {
          const onHash = () => {
            setHash(window.location.hash || "#/");
            // 當路由改變時，自動滾動到頁面頂部
            window.scrollTo(0, 0);
          };
          window.addEventListener("hashchange", onHash);
          return () => window.removeEventListener("hashchange", onHash);
        }, []);
        const push = (h) => { 
          if (h !== window.location.hash) {
            window.location.hash = h;
            // 當程式化改變路由時，也滾動到頂部
            window.scrollTo(0, 0);
          }
        };
        return { hash, push };
      };

      const POS_LABEL = {
        noun: "名詞", verb: "動詞", adjective: "形容詞", adverb: "副詞",
        pronoun: "代名詞", preposition: "介系詞", conjunction: "連接詞", other: "其他"
      };
      const ALL_POS = Object.keys(POS_LABEL);
      
      // 主題標籤
      const THEME_LABEL = {
        highschool_climate: "高中氣候"
      };
      const ALL_THEMES = Object.keys(THEME_LABEL);
      
      const LS = { favorites: "mvp_vocab_favorites", dataset: "mvp_vocab_dataset_v36", presetApplied: "mvp_vocab_preset_applied_v36", homeFilters: "mvp_home_filters_v1", userExamples: "mvp_vocab_user_examples_v1" };
      const PRESET_VERSION = 'csv_v8';
      const HIGH_SCHOOL_CLIMATE_CSV_EMBEDDED = ""; // 清空舊的嵌入資料

      const CSV_SOURCES = [
        { name: '高中氣候', urls: ['高中單字表試做 - 主題：氣候彙整.csv'], defaults: { theme: 'highschool_climate' } }
      ];

const speak = (rawText) => {
        const text = String(rawText || '').trim();
        if (!text || !('speechSynthesis' in window)) return;
        try {
          window.speechSynthesis.cancel();
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.lang = 'en-US';
          window.speechSynthesis.speak(utterance);
        } catch {}
      };

      const Button = ({ children, onClick, variant = "primary", type = "button", className = "", disabled = false }) => {
        const base = "px-4 py-2 rounded-xl font-medium transition focus:outline-none focus:ring-2 focus:ring-offset-2";
        const variants = {
          primary: "bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500",
          ghost: "bg-white/80 text-gray-700 border border-gray-200 hover:bg-white focus:ring-gray-300",
          danger: "bg-rose-600 text-white hover:bg-rose-700 focus:ring-rose-500"
        };
        const variantClass = variants[variant] || variants.primary;
        const disabledClass = disabled ? "opacity-60 cursor-not-allowed hover:bg-inherit" : "";
        return (
          <button
            type={type}
            onClick={disabled ? undefined : onClick}
            disabled={disabled}
            className={`${base} ${variantClass} ${disabledClass} ${className}`}
          >
            {children}
          </button>
        );
      };

      const SpeakerButton = ({ onClick, label, className = "" }) => (
        <button
          type="button"
          onClick={onClick}
          aria-label={label}
          title={label}
          className={`inline-flex h-8 w-8 items-center justify-center rounded-full border border-indigo-200 bg-white text-indigo-600 shadow-sm transition hover:bg-indigo-50 hover:text-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 ${className}`}
        >
          <svg viewBox="0 0 24 24" fill="currentColor" className="h-4 w-4">
            <path d="M4 9.25v5.5c0 .69.56 1.25 1.25 1.25H7l3.29 2.63c.83.66 2.04.07 2.04-1V6.62c0-1.07-1.21-1.66-2.04-1L7 8.25H5.25C4.56 8.25 4 8.81 4 9.25Zm11.21-2.46a.75.75 0 0 0-.97 1.14 4.5 4.5 0 0 1 0 7.14.75.75 0 0 0 .97 1.14 6 6 0 0 0 0-9.42Zm2.79-1.95a.75.75 0 0 0-.97 1.13 7.5 7.5 0 0 1 0 11.56.75.75 0 0 0 .97 1.13 9 9 0 0 0 0-13.82Z" />
          </svg>
        </button>
      );

            window.__INITIAL_DATASET__ = [];

      const exampleFor = (word, pos) => {
        const w = String(word || '').trim();
        if (!w) return '';
        const lower = w.toLowerCase();
        const article = /^[aeiou]/i.test(w) ? 'an' : 'a';
        if (pos === 'adjective' && lower === 'alike') return 'They look alike.';
        if (pos === 'verb') return `They ${lower} every day.`;
        if (pos === 'adjective') return `It is ${lower}.`;
        if (pos === 'adverb') return `He speaks ${lower}.`;
        if (pos === 'preposition') return `We talked ${lower} the plan.`;
        if (pos === 'conjunction') return `I left ${lower} the rain started.`;
        if (pos === 'pronoun') return `${w} is here.`;
        return `This is ${article} ${lower}.`;
      };

      const translationFor = (word, pos) => {
        const w = String(word || '').trim();
        if (!w) return '';
        const lower = w.toLowerCase();
        const DICT_ZH = {
          activity: "活動", action: "行動", actor: "男演員", actress: "女演員", add: "加",
          about: "關於", above: "在上方", across: "穿越", against: "反對", along: "沿著", among: "在…之中", around: "在周圍", as: "作為/因為", after: "之後",
          afraid: "害怕的", angry: "生氣的", able: "能夠的", active: "活躍的", alive: "活著的", alike: "相似",
          animal: "動物", airport: "機場", apple: "蘋果", agree: "同意", arrive: "到達", ask: "詢問",
          available: "可用的", away: "離開的", we: "我們", you: "你/你們", they: "他們"
        };
        const PREP_ZH = {
          about: "關於", above: "在…上方", across: "穿越/橫越", against: "反對/靠著",
          along: "沿著", among: "在…之中", around: "在…周圍/大約", as: "作為/因為", after: "在…之後"
        };
        if (pos === 'verb') {
          const zh = DICT_ZH[lower] || w;
          return `他們每天${zh}。`;
        }
        if (pos === 'adjective') {
          if (lower === 'alike') return '他們看起來很相似。';
          const zh = DICT_ZH[lower] || `${w}的`;
          return `它很${zh.replace(/的$/, '的')}。`;
        }
        if (pos === 'adverb') {
          const zh = DICT_ZH[lower] || w;
          return `他說話${zh}地。`;
        }
        if (pos === 'pronoun') {
          const zh = DICT_ZH[lower] || w;
          return `${zh}在這裡。`;
        }
        if (pos === 'preposition') {
          const zh = PREP_ZH[lower] || DICT_ZH[lower] || w;
          return `我們談論${zh}這個計畫。`;
        }
        if (pos === 'conjunction') {
          return `我在${DICT_ZH[lower] || w}雨開始時離開。`;
        }
        const zh = DICT_ZH[lower] || w;
        const isZh = /[\u4e00-\u9fff]/.test(zh);
        return `這是${isZh ? '' : '一個'}${zh}。`;
      };
      
      const posLabelFromArray = (tags = []) => {
        return (Array.isArray(tags) ? tags : [])
          .map((tag) => POS_LABEL[tag] || tag)
          .filter(Boolean)
          .join('、');
      };

      const wordToMarkdown = (word, selPos, extras = {}) => {
        if (!word) return '';
        const sections = extras.sections || { pos: true, relations: true, affix: true };
        const lines = [];
        const heading = (extras.title ?? word.english_word ?? '').trim();
        if (heading) {
          lines.push(`## ${heading}`);
        }

        const basicLines = [];
        const kk = (extras.kk_phonetic ?? word.kk_phonetic ?? '').trim();
        if (kk) basicLines.push(`- KK音標：${kk}`);
        const posText = posLabelFromArray(word.posTags || []);
        if (posText) basicLines.push(`- 詞性：${posText}`);
        const levelText = String(extras.level ?? word.level ?? '').trim();
        if (levelText) basicLines.push(`- Level：${levelText}`);
        const themeLabels = getThemeDisplayLabels(word);
        if (themeLabels.length) basicLines.push(`- 主題：${themeLabels.join('、')}`);
        if (basicLines.length) {
          if (lines.length) lines.push('');
          lines.push('### 基本資訊', ...basicLines);
        }

        const exampleLines = [];
        const exampleSentence = (extras.example_sentence ?? word.example_sentence ?? '').trim();
        const exampleTranslation = (extras.example_translation ?? word.example_translation ?? '').trim();
        const exampleSentence2 = (extras.example_sentence_2 ?? word.example_sentence_2 ?? '').trim();
        const exampleTranslation2 = (extras.example_translation_2 ?? word.example_translation_2 ?? '').trim();
        if (exampleSentence) exampleLines.push(`- 例句1：${exampleSentence}`);
        if (exampleTranslation) exampleLines.push(`  → ${exampleTranslation}`);
        if (exampleSentence2) exampleLines.push(`- 例句2：${exampleSentence2}`);
        if (exampleTranslation2) exampleLines.push(`  → ${exampleTranslation2}`);
        if (exampleLines.length) {
          lines.push('', '### 例句', ...exampleLines);
        }

        if (sections.pos) {
          const grammarLines = [];
          const primaryPos = selPos || word.grammar_main_category || (word.posTags || [])[0];
          if (primaryPos) grammarLines.push(`- 主要詞性：${POS_LABEL[primaryPos] || primaryPos}`);
          const subCat = (extras.grammar_sub_category ?? word.grammar_sub_category ?? '').trim();
          if (subCat) grammarLines.push(`- 子分類：${subCat}`);
          const gFunc = (extras.grammar_function ?? word.grammar_function ?? '').trim();
          if (gFunc) grammarLines.push(`- 語法功能：${gFunc}`);
          const gPattern = (extras.applicable_sentence_pattern ?? word.applicable_sentence_pattern ?? '').trim();
          if (gPattern) grammarLines.push(`- 常見句型：${gPattern}`);
          const formsSource = extras.word_forms ?? word.word_forms ?? [];
          const formsList = Array.isArray(formsSource) ? formsSource : multiSplit(formsSource || '');
          const cleanedForms = formsList.filter(Boolean);
          if (cleanedForms.length) grammarLines.push(`- 詞性變化：${cleanedForms.join('、')}`);
          if (grammarLines.length) {
            lines.push('', '### 詞性', ...grammarLines);
          }
        }

        if (sections.relations) {
          const relationLines = [];
          const synonyms = extras.synonyms ?? word.synonyms ?? [];
          const synList = Array.isArray(synonyms) ? synonyms : multiSplit(synonyms || '');
          if (synList.length) relationLines.push(`- 同義字：${synList.join('、')}`);
          const antonyms = extras.antonyms ?? word.antonyms ?? [];
          const antList = Array.isArray(antonyms) ? antonyms : multiSplit(antonyms || '');
          if (antList.length) relationLines.push(`- 反義字：${antList.join('、')}`);
          const confusables = extras.confusables ?? word.confusables ?? [];
          const confList = Array.isArray(confusables) ? confusables : multiSplit(confusables || '');
          if (confList.length) relationLines.push(`- 易混淆字：${confList.join('、')}`);
          if (relationLines.length) {
            lines.push('', '### 同義／反義／易混淆', ...relationLines);
          }
        }

        if (sections.affix) {
          const affix = extras.affix_info ?? word.affix_info ?? {};
          const affixLines = [];
          const prefix = String(affix.prefix || '').trim();
          const root = String(affix.root || '').trim();
          const suffix = String(affix.suffix || '').trim();
          const meaning = String(affix.meaning || '').trim();
          const example = String(affix.example || '').trim();
          if (prefix) affixLines.push(`- 字首：${prefix}`);
          if (root) affixLines.push(`- 字根：${root}`);
          if (suffix) affixLines.push(`- 字尾：${suffix}`);
          if (meaning) affixLines.push(`- 字源意涵：${meaning}`);
          if (example) affixLines.push(`- 延伸例子：${example}`);
          if (affixLines.length) {
            lines.push('', '### 字根字首字尾', ...affixLines);
          }
        }

        return lines.join('\n');
      };

      const makeBaseDataset = () => [];

      const normalizePOS = (raw) => {
        const s=String(raw||"").toLowerCase();
        if (s.includes("代名") || s.includes("pronoun")) return "pronoun";
        if (s.includes("副詞") || s.includes("adv")) return "adverb";
        if (s.includes("形容") || s.includes("adj")) return "adjective";
        if (s.includes("動詞") || s.includes("verb") || s==="v") return "verb";
        if (s.includes("名詞") || s.includes("noun") || s==="n") return "noun";
        if (s.includes("介系") || s.includes("preposition") || s.includes("prep")) return "preposition";
        if (s.includes("連接") || s.includes("conjunction") || s.includes("conj")) return "conjunction";
        return "other";
      };

      const multiSplit = (text) => {
        const out = []; let token = ""; const str = String(text);
        const isDelim = (ch) => /[,;\/，、\n\r]/.test(ch);
        for (let i=0; i<str.length; i++) {
          const ch = str[i];
          if (isDelim(ch)) { if (token) out.push(token); token = ""; } else { token += ch; }
        }
        if (token) out.push(token);
        return out.map(s=>s.trim()).filter(Boolean);
      };

      const emptyWordFormsDetail = () => ({ base: [], idiom: [], compound: [], derivation: [] });

      const dedupeList = (arr=[]) => Array.from(new Set(arr.map(s=>s.trim()).filter(Boolean)));

      const mergeThemes = (...values) => {
        const result = new Set();
        const ingest = (val, allowSplit = true) => {
          if (val === undefined || val === null) return;
          if (Array.isArray(val)) { val.forEach((item) => ingest(item, true)); return; }
          const str = String(val).trim();
          if (!str) return;
          if (allowSplit) {
            const tokens = multiSplit(str);
            if (tokens.length > 1) {
              tokens.forEach((token) => ingest(token, false));
              return;
            }
          }
          result.add(str);
        };
        values.forEach((val) => ingest(val, true));
        return Array.from(result);
      };

      const getWordThemes = (word) => mergeThemes(word?.themes, word?.theme);
      const wordHasTheme = (word, themeKey) => {
        if (!themeKey) return false;
        return getWordThemes(word).includes(themeKey);
      };
      
      // 將主題鍵對應到顯示標籤，避免重複顯示
      const getThemeDisplayLabels = (word) => {
        const themes = getWordThemes(word);
        const labels = new Set();
        
        themes.forEach(theme => {
          if (theme === '氣候' || theme === 'climate') {
            labels.add('高中氣候');
          } else {
            labels.add(THEME_LABEL[theme] || theme);
          }
        });
        
        return Array.from(labels);
      };

      const categorizeWordForms = (source=[], baseWord='') => {
        const detail = emptyWordFormsDetail();
        const baseLower = String(baseWord||'').toLowerCase();
        source.forEach(item => {
          const text = String(item || '').trim();
          if (!text) return;
          const lower = text.toLowerCase();
          if (text.includes('*') || (baseLower && lower === baseLower)) {
            detail.base.push(text);
          }
          else if (/[\s]/.test(text) && !text.includes('-')) {
            detail.idiom.push(text);
          }
          else if (text.includes('-')) {
            detail.compound.push(text);
          }
          else if (baseLower && (lower.startsWith(baseLower) || baseLower.startsWith(lower))) {
            detail.derivation.push(text);
          }
          else {
            detail.derivation.push(text);
          }
        });
        detail.base = dedupeList(detail.base);
        detail.idiom = dedupeList(detail.idiom);
        detail.compound = dedupeList(detail.compound);
        detail.derivation = dedupeList(detail.derivation);
        return detail;
      };

      const normalizeWordFormsDetail = (rawDetail, fallback=[], baseWord='') => {
        let detail = emptyWordFormsDetail();
        if (rawDetail && typeof rawDetail === 'object' && !Array.isArray(rawDetail)) {
          detail.base = dedupeList(rawDetail.base || rawDetail.root || []);
          detail.idiom = dedupeList(rawDetail.idiom || rawDetail.phrase || []);
          detail.compound = dedupeList(rawDetail.compound || rawDetail.compounds || []);
          detail.derivation = dedupeList(rawDetail.derivation || rawDetail.other || rawDetail.misc || []);
        }
        const remaining = [];
        if (Array.isArray(rawDetail)) remaining.push(...rawDetail);
        if (Array.isArray(fallback)) remaining.push(...fallback);
        if (typeof fallback === 'string') remaining.push(...multiSplit(fallback));
        const categorized = categorizeWordForms(remaining, baseWord);
        if (!detail.base.length) detail.base = categorized.base;
        if (!detail.idiom.length) detail.idiom = categorized.idiom;
        if (!detail.compound.length) detail.compound = categorized.compound;
        if (!detail.derivation.length) detail.derivation = categorized.derivation;
        return detail;
      };

      const ensureWordFormsDetail = (word) => {
        const detail = normalizeWordFormsDetail(word.word_forms_detail, word.word_forms, word.english_word);
        const combined = dedupeList([...detail.base, ...detail.idiom, ...detail.compound, ...detail.derivation]);
        const themeList = mergeThemes(word.themes, word.theme);
        const primaryTheme = themeList.length ? themeList[0] : (String(word.theme || '').trim() || '');
        return {
          ...word,
          word_forms_detail: detail,
          // 保留原始的 word_forms 字串，不要覆蓋
          // word_forms: combined,
          theme: primaryTheme,
          themes: themeList
        };
      };

      const INITIAL_DATASET_RAW = (window.__INITIAL_DATASET__ || []);
      const INITIAL_DATASET = INITIAL_DATASET_RAW.map(ensureWordFormsDetail);


      const mergeWordFormsDetail = (target, source) => {
        const base = target ? {
          base: dedupeList(target.base || []),
          idiom: dedupeList(target.idiom || []),
          compound: dedupeList(target.compound || []),
          derivation: dedupeList(target.derivation || [])
        } : emptyWordFormsDetail();
        if (!source) return base;
        base.base = dedupeList([...base.base, ... (source.base || [])]);
        base.idiom = dedupeList([...base.idiom, ... (source.idiom || [])]);
        base.compound = dedupeList([...base.compound, ... (source.compound || [])]);
        base.derivation = dedupeList([...base.derivation, ... (source.derivation || source.other || [])]);
        return base;
      };

      function parseCSV(text) {
        const rows = [];
        let i=0, cur='', inQ=false, row=[];
        const pushCell=()=>{ row.push(cur); cur=''; };
        const pushRow=()=>{ rows.push(row); row=[]; };
        while(i<text.length){
          const ch=text[i];
          if(ch==='"') { if(inQ && text[i+1]==='"'){ cur+='"'; i+=2; continue; } inQ=!inQ; i++; continue; }
          if(!inQ && ch===','){ pushCell(); i++; continue; }
          if(!inQ && ch==='\n'){ pushCell(); pushRow(); i++; continue; }
          if(!inQ && ch==='\r' && text[i+1]==='\n'){ pushCell(); pushRow(); i+=2; continue; }
          cur+=ch; i++;
        }
        if(cur.length||row.length){ pushCell(); pushRow(); }
        if(!rows.length) return [];
        const headers=(rows[0]||[]).map(h=>String(h||'').replace(/^\uFEFF/, '').trim());
      
        return rows.slice(1).map(cols=>{ const obj={}; for(let k=0;k<headers.length;k++){ const key=headers[k]; if(!key) continue; obj[key]=(cols[k]||'').trim(); } return obj; });
      }

      const ADV_FREQUENCY = new Set(['always','usually','often','sometimes','seldom','rarely','never','again']);
      const ADV_DEGREE    = new Set(['very','quite','too','enough','almost','altogether']);
      const ADV_PLACE     = new Set(['here','there','above','below','abroad','anywhere','away','around','along','ahead']);
      const ADV_TIME      = new Set(['already','now','today','yesterday','tonight','soon']);
      const ADV_MANNER    = new Set(['aloud','alone']);

      const grammarDefaults = (word, pos, subcat='') => {
        const w = String(word);
        const lw = w.toLowerCase();
        const s = String(subcat||'');
        let func = '', patt = '';
        if (pos === 'pronoun') {
          if (s.includes('主格')) { func = '作主詞（Subject）'; patt = `${w} + V ...`; }
          else if (s.includes('受格')) { func = '作受詞（Object）'; patt = `S + V + ${w}`; }
          else if (s.includes('所有格形容')) { func = '修飾名詞（所有格形容詞）'; patt = `${w} + N`; }
          else if (s.includes('所有格')) { func = '代替名詞片語（所有格代名詞）'; patt = `S + be + ${w}`; }
          else if (s.includes('反身')) { func = '反身受詞／強調'; patt = `S + V + ${w}`; }
          else { func = '代替名詞（泛指）'; patt = `${w} + V ... / S + V + ${w}`; }
        }
        else if (pos === 'adverb') {
          if (ADV_FREQUENCY.has(lw)) { func = '頻率副詞：修飾動詞（be/助動詞之後、一般動詞之前）'; patt = 'S + (助動詞) + [頻率副詞] + V ... / be + [頻率副詞]'; }
          else if (ADV_DEGREE.has(lw)) { func = '程度副詞：修飾形容詞/副詞'; patt = '[程度副詞] + Adj/Adv'; }
          else if (ADV_PLACE.has(lw)) { func = '地點/方向副詞：常置句末或動詞後'; patt = 'S + V + (O) + [地點副詞]'; }
          else if (ADV_TIME.has(lw)) { func = '時間副詞：句末或句首'; patt = '[時間副詞], S + V ... / S + V + [時間副詞]'; }
          else if (ADV_MANNER.has(lw)) { func = '方式副詞：說明動作方式'; patt = 'S + V + [方式副詞]'; }
          else if (lw === 'also') { func = '添加副詞：也、還'; patt = 'S + also + V / be + also'; }
          else { func = '副詞：修飾動詞、形容詞或整句'; patt = 'S + V + (O) + Adv / Adv + 句子'; }
        }
        return { grammar_function: func, sentence_pattern: patt };
      };

      const useDataset = () => {
        const themeOrderRef = useRef({});

        const applyThemeOrder = (word, themes, counters = themeOrderRef.current) => {
          if (!word) return word;
          const list = Array.isArray(themes) ? themes : getWordThemes(word);
          if (!word.theme_order) word.theme_order = {};
          list.forEach((theme) => {
            const key = String(theme || '').trim();
            if (!key) return;
            if (word.theme_order[key] === undefined) {
              const idx = counters[key] ?? 0;
              word.theme_order[key] = idx;
              counters[key] = idx + 1;
            }
          });
          return word;
        };

        const hydrateDataset = (items, resetCounters = true) => {
          const counters = resetCounters ? {} : { ...themeOrderRef.current };
          const hydrated = (Array.isArray(items) ? items : []).map((item) => {
            const prepared = ensureWordFormsDetail(item);
            const clone = { ...prepared };
            if (clone.theme_order && typeof clone.theme_order === 'object') {
              Object.entries(clone.theme_order).forEach(([theme, order]) => {
                const num = Number(order);
                if (Number.isFinite(num) && num >= 0) {
                  counters[theme] = Math.max(counters[theme] || 0, num + 1);
                }
              });
            }
            applyThemeOrder(clone, getWordThemes(clone), counters);
            return clone;
          });
          themeOrderRef.current = counters;
          return hydrated;
        };

        const [data, setData] = useState(() => {
          try {
            const storedVersion = localStorage.getItem(LS.presetApplied);
            if (storedVersion === PRESET_VERSION) {
              const raw = localStorage.getItem(LS.dataset);
              if (raw) {
                const parsed = JSON.parse(raw);
                if (Array.isArray(parsed) && parsed.length) {
                  return hydrateDataset(parsed);
                }
              }
            }
          } catch {}
          try {
            localStorage.removeItem(LS.dataset);
            localStorage.removeItem(LS.presetApplied);
          } catch {}
          return hydrateDataset(makeBaseDataset());
        });

        useEffect(() => {
          try { localStorage.setItem(LS.dataset, JSON.stringify(data)); } catch {}
        }, [data]);

        const addItems = (items, opts = {}) => {
          const overrideExamples = !!opts.overrideExamples;
          const replace = !!opts.replace;
          const stats = { added: 0, merged: 0, replaced: 0, tagsAdded: {}, totalBefore: 0, totalAfter: 0 };
          const incomingList = Array.isArray(items) ? items : [];

          setData((current) => {
            stats.totalBefore = current.length;
            const baseCounters = {};
            const preparedCurrent = current.map((item) => {
              const prepared = ensureWordFormsDetail(item);
              const clone = { ...prepared };
              applyThemeOrder(clone, getWordThemes(clone), baseCounters);
              return clone;
            });

            const counters = replace ? {} : baseCounters;
            if (replace) {
              stats.replaced = current.length;
            }
            themeOrderRef.current = counters;

            const next = replace ? [] : preparedCurrent;
            const byWord = new Map(next.map((w) => [String(w.english_word || '').toLowerCase(), w]));
            let maxId = next.reduce((m, w) => Math.max(m, Number(w.id) || 0), 0);

            const mergeAffixInfo = (target, source) => {
              if (!source) return;
              if (!target.affix_info) {
                target.affix_info = { prefix: '', root: '', suffix: '', meaning: '', example: '' };
              }
              ['prefix', 'root', 'suffix', 'meaning', 'example'].forEach((key) => {
                if (!target.affix_info[key] && source[key]) {
                  target.affix_info[key] = source[key];
                }
              });
            };

            const ensureTag = (wordObj, tag) => {
              if (!tag) return;
              if (!wordObj.posTags) wordObj.posTags = [];
              if (!wordObj.posTags.includes(tag)) {
                wordObj.posTags = [...wordObj.posTags, tag];
                wordObj.basic_pos = wordObj.posTags.join(', ');
                stats.tagsAdded[tag] = (stats.tagsAdded[tag] || 0) + 1;
              }
            };

            incomingList.forEach((raw) => {
              if (!raw) return;
              const english = String(raw.english_word || raw.word || raw.Word || raw['英文'] || raw['英文單字'] || '').trim();
              if (!english) return;

              const posSources = [raw.posTags, raw.basic_pos, raw.grammar_main_category, raw['詞性'], raw['詞性分類'], raw.pos];
              const tagTokens = [];
              posSources.forEach((src) => {
                if (!src) return;
                if (Array.isArray(src)) tagTokens.push(...src);
                else tagTokens.push(...multiSplit(src));
              });
              const tags = Array.from(new Set(tagTokens.map(normalizePOS).filter(Boolean)));
              if (!tags.length) tags.push('other');

              const formsRaw = raw.word_forms ?? raw['詞性變化'];
              // 保留原始字串用於顯示，同時為 normalizeWordFormsDetail 準備陣列
              const formsForDetail = Array.isArray(formsRaw) ? formsRaw : multiSplit(formsRaw || '');
              const levelValue = raw.level ?? raw.Level ?? raw.LEVEL ?? raw['Level'] ?? raw['LEVEL'] ?? '';
              const level = String(levelValue || '').trim();
              const normalizedDetail = normalizeWordFormsDetail(raw.word_forms_detail, formsForDetail, english);
              let themes = mergeThemes(raw.themes, raw.theme, raw['主題'], raw.default_theme, raw.defaultTheme);
              if (!themes.length && tags.length) themes = mergeThemes(tags[0]);
              if (!themes.length) themes = ['general'];

              const toList = (value, alt) => Array.isArray(value) ? value : multiSplit(value || alt || '');
              const derivatives = toList(raw.derivatives, raw['衍生詞']);
              const synonyms = toList(raw.synonyms, raw['同義字']);
              const antonyms = toList(raw.antonyms, raw['反義字']);
              const confusables = toList(raw.confusables, raw['易混淆字']);

              const affixSource = (raw.affix_info && typeof raw.affix_info === 'object') ? raw.affix_info : {};
              const incoming = ensureWordFormsDetail({
                id: null,
                english_word: english,
                kk_phonetic: raw.kk_phonetic || raw.KK || raw['KK音標'] || '',
                chinese_definition: raw.chinese_definition || raw['中譯'] || raw['中文'] || '',
                posTags: tags,
                basic_pos: tags.join(', '),
                grammar_main_category: normalizePOS(tags[0] || raw.grammar_main_category || raw['詞性'] || ''),
                grammar_sub_category: raw.grammar_sub_category || raw['詞性分類'] || '',
                grammar_function: raw.grammar_function || raw['語法功能'] || '',
                applicable_sentence_pattern: raw.applicable_sentence_pattern || raw['句型'] || '',
                example_sentence: raw.example_sentence || raw['例句'] || raw['ai例句'] || '',
                example_translation: raw.example_translation || raw['翻譯'] || raw['ai例句中譯'] || '',
                example_sentence_2: raw.example_sentence_2 || raw['例句2'] || raw['例句_2'] || raw.sentence2 || raw['GSAT_Example_Sentence_1'] || '',
                example_translation_2: raw.example_translation_2 || raw['翻譯2'] || raw['翻譯_2'] || raw.translation2 || raw['GSAT_Translation_1'] || '',
                example_sentence_3: raw.example_sentence_3 || raw['例句3'] || raw['例句_3'] || raw.sentence3 || '',
                example_translation_3: raw.example_translation_3 || raw['翻譯3'] || raw['翻譯_3'] || raw.translation3 || '',
                example_sentence_4: raw.example_sentence_4 || raw['例句4'] || raw['例句_4'] || raw.sentence4 || '',
                example_translation_4: raw.example_translation_4 || raw['翻譯4'] || raw['翻譯_4'] || raw.translation4 || '',
                example_sentence_5: raw.example_sentence_5 || raw['例句5'] || raw['例句_5'] || raw.sentence5 || '',
                example_translation_5: raw.example_translation_5 || raw['翻譯5'] || raw['翻譯_5'] || raw.translation5 || '',
                example_source_2: (() => {
                  // 優先使用已處理的 example_source_2
                  if (raw.example_source_2) return raw.example_source_2;
                  // 否則從 Year_1, Part_1, Source_1 組合
                  const year = raw['Year_1'] || '';
                  const part = raw['Part_1'] || '';
                  const source = raw['Source_1'] || '';
                  if (year && part && source) {
                    return `${year}\t${part}\t${source}`;
                  }
                  return '';
                })(),
                theme: themes[0] || '',
                themes,
                level,
                cefr: raw.cefr || raw.CEFR || raw['CEFR'] || '',
                word_forms: formsRaw || '', // 使用原始字串，保留換行
                word_forms_detail: normalizedDetail,
                derivatives,
                synonyms,
                antonyms,
                confusables,
                phrases: Array.isArray(raw.phrases) ? raw.phrases : (typeof raw.phrases === 'string' ? raw.phrases.split(';').map(p => p.trim()).filter(p => p) : (raw['片語'] || '').split(';').map(p => p.trim()).filter(p => p)),
                affix_info: {
                  prefix: affixSource.prefix || raw.affix_prefix || raw.prefix || raw['字首'] || '',
                  root: affixSource.root || raw.affix_root || raw.root || raw['字根'] || '',
                  suffix: affixSource.suffix || raw.affix_suffix || raw.suffix || raw['字尾'] || '',
                  meaning: affixSource.meaning || raw.affix_meaning || raw.meaning || raw['意思'] || '',
                  example: affixSource.example || raw.affix_example || raw.example || raw['例子'] || ''
                }
              });

              const key = english.toLowerCase();
              const existing = byWord.get(key);
              if (existing) {
                incoming.posTags.forEach((tag) => ensureTag(existing, tag));
                const combinedThemes = mergeThemes(existing.themes, existing.theme, themes);
                existing.themes = combinedThemes;
                if (!existing.theme && combinedThemes.length) existing.theme = combinedThemes[0];
                if (level) existing.level = level;
                applyThemeOrder(existing, combinedThemes, counters);

                if (!existing.kk_phonetic && incoming.kk_phonetic) existing.kk_phonetic = incoming.kk_phonetic;
                if (!existing.chinese_definition && incoming.chinese_definition) existing.chinese_definition = incoming.chinese_definition;
                if (!existing.grammar_main_category && incoming.grammar_main_category) existing.grammar_main_category = incoming.grammar_main_category;
                if (!existing.grammar_sub_category && incoming.grammar_sub_category) existing.grammar_sub_category = incoming.grammar_sub_category;
                if (!existing.grammar_function && incoming.grammar_function) existing.grammar_function = incoming.grammar_function;
                if (!existing.applicable_sentence_pattern && incoming.applicable_sentence_pattern) existing.applicable_sentence_pattern = incoming.applicable_sentence_pattern;
                if (!existing.theme && incoming.theme) existing.theme = incoming.theme;

                const primaryPos = existing.posTags?.[0] || incoming.posTags[0] || 'noun';
                const autoSentence = exampleFor(existing.english_word, primaryPos);
                const autoTranslation = translationFor(existing.english_word, primaryPos);

                if (incoming.example_sentence && (overrideExamples || !existing.example_sentence || existing.example_sentence === autoSentence)) {
                  existing.example_sentence = incoming.example_sentence;
                }
                if (incoming.example_translation && (overrideExamples || !existing.example_translation || existing.example_translation === autoTranslation)) {
                  existing.example_translation = incoming.example_translation;
                }
                if (incoming.example_sentence_2 && (overrideExamples || !existing.example_sentence_2)) {
                  existing.example_sentence_2 = incoming.example_sentence_2;
                }
                if (incoming.example_translation_2 && (overrideExamples || !existing.example_translation_2)) {
                  existing.example_translation_2 = incoming.example_translation_2;
                }

                existing.word_forms_detail = mergeWordFormsDetail(existing.word_forms_detail, incoming.word_forms_detail);
                // word_forms 是字串，不需要合併，只更新
                if (incoming.word_forms && !existing.word_forms) {
                  existing.word_forms = incoming.word_forms;
                }
                existing.derivatives = dedupeList([...(existing.derivatives || []), ...incoming.derivatives]);
                existing.synonyms = dedupeList([...(existing.synonyms || []), ...incoming.synonyms]);
                existing.antonyms = dedupeList([...(existing.antonyms || []), ...incoming.antonyms]);
                existing.confusables = dedupeList([...(existing.confusables || []), ...incoming.confusables]);
                // phrases 是陣列
                existing.phrases = dedupeList([...(existing.phrases || []), ...(incoming.phrases || [])]);
                mergeAffixInfo(existing, incoming.affix_info);

                Object.assign(existing, ensureWordFormsDetail(existing));
                stats.merged += 1;
              } else {
                maxId += 1;
                const firstPos = incoming.posTags[0] || 'other';
                const primaryTheme = incoming.theme || themes[0] || 'general';
                const newWord = ensureWordFormsDetail({
                  ...incoming,
                  id: maxId,
                  theme: primaryTheme,
                  themes,
                  grammar_main_category: incoming.grammar_main_category || firstPos,
                  example_sentence: incoming.example_sentence || exampleFor(english, firstPos),
                  example_translation: incoming.example_translation || translationFor(english, firstPos)
                });
                newWord.posTags = incoming.posTags;
                newWord.basic_pos = incoming.posTags.join(', ');
                if (!newWord.theme) newWord.theme = primaryTheme;
                newWord.themes = mergeThemes(newWord.themes, newWord.theme);
                applyThemeOrder(newWord, newWord.themes, counters);
                if (incoming.affix_info) newWord.affix_info = incoming.affix_info;
                next.push(newWord);
                byWord.set(key, newWord);
                stats.added += 1;
              }
            });

            themeOrderRef.current = counters;
            stats.totalAfter = next.length;
            return next;
          });

          return stats;
        };

        const reset = () => {
          try {
            localStorage.removeItem(LS.dataset);
            localStorage.removeItem(LS.presetApplied);
          } catch {}
          setData(hydrateDataset(makeBaseDataset()));
        };

        useEffect(() => {
          let cancelled = false;
          const ensureCsvPreset = async () => {
            try { if (localStorage.getItem(LS.presetApplied) === PRESET_VERSION) return; } catch {}
            const aggregated = [];
            for (const source of CSV_SOURCES) {
              let text = '';
              const candidates = Array.isArray(source.urls) && source.urls.length ? source.urls : [source.url];
              for (const rawUrl of candidates) {
                const url = encodeURI(rawUrl);
                try {
                  const res = await fetch(url);
                  if (!res.ok) continue;
                  text = await res.text();
                  if (text) text = text.replace(/^﻿/, '');
                  if (text) break;
                } catch (err) {
                  // try next candidate
                }
              }
              if (!text && source.embeddedText) {
                text = source.embeddedText;
              }
              if (text) text = text.replace(/^﻿/, '');
              if (!text) continue;

              const rows = parseCSV(text);
              const defaultTheme = source.defaults?.theme || '';
              const effectiveRows = source.limit ? rows.slice(0, source.limit) : rows;
              effectiveRows.forEach((row) => {
                const english = (row.word || row['word'] || row['english_word'] || row['英文'] || row['英文單字'] || row.word_lower || '').trim();
                if (!english) return;
                const themes = mergeThemes(row.themes, row['主題'], row['theme'], defaultTheme);
                const primaryTheme = themes.length ? themes[0] : defaultTheme;
                aggregated.push({
                  english_word: english,
                  kk_phonetic: row['KK音標'] || row['KK'] || '',
                  chinese_definition: row['中譯'] || row['definition'] || row['鍾意'] || '',
                  example_sentence: row['例句'] || row['sentence'] || row['ai例句'] || row['example_sentence'] || '',
                  example_translation: row['翻譯'] || row['translation'] || row['ai例句中譯'] || row['example_translation'] || '',
                  example_sentence_2: row['例句2'] || row['例句_2'] || row['sentence2'] || row['GSAT_Example_Sentence_1'] || row['example_sentence_2'] || '',
                  example_translation_2: row['翻譯2'] || row['翻譯_2'] || row['translation2'] || row['GSAT_Translation_1'] || row['example_translation_2'] || '',
                  example_sentence_3: row['例句3'] || row['例句_3'] || row['sentence3'] || row['example_sentence_3'] || '',
                  example_translation_3: row['翻譯3'] || row['翻譯_3'] || row['translation3'] || row['example_translation_3'] || '',
                  example_sentence_4: row['例句4'] || row['例句_4'] || row['sentence4'] || row['example_sentence_4'] || '',
                  example_translation_4: row['翻譯4'] || row['翻譯_4'] || row['translation4'] || row['example_translation_4'] || '',
                  example_sentence_5: row['例句5'] || row['例句_5'] || row['sentence5'] || row['example_sentence_5'] || '',
                  example_translation_5: row['翻譯5'] || row['翻譯_5'] || row['translation5'] || row['example_translation_5'] || '',
                  example_source_2: (() => {
                    const year = row['Year_1'] || row['N'] || '';
                    const part = row['Part_1'] || row['O'] || '';
                    const source = row['Source_1'] || row['P'] || '';
                    if (year && part && source) {
                      return `${year}\t${part}\t${source}`;
                    }
                    return '';
                  })(),
                  grammar_main_category: row['詞性'] || row['副詞'] || row['pos'] || '',
                  grammar_sub_category: row['詞性分類'] || row['子分類'] || row['subcat'] || '',
                  theme: primaryTheme || '',
                  themes,
                  default_theme: defaultTheme,
                  level: row['level'] || row['Level'] || row['LEVEL'] || '',
                  cefr: row['CEFR'] || row['cefr'] || '',
                  word_forms: row['詞性變化'] || row['詞形變化'] || row['詞形說明'] || row['word_forms'] || '',
                  derivatives: row['衍生詞'] || row['derivatives'] || '',
                  synonyms: row['同義字'] || row['synonyms'] || '',
                  antonyms: row['反義字'] || row['antonyms'] || '',
                  confusables: row['易混淆字'] || row['confusables'] || '',
                  phrases: (row['片語'] || row['phrases'] || '').split(/[;；]/).map(p => p.trim()).filter(p => p),
                  word_forms_detail: row['word_forms_detail'],
                  affix_info: {
                    prefix: row['字首'] || row['prefix'] || '',
                    root: row['字根'] || row['root'] || '',
                    suffix: row['字尾'] || row['suffix'] || '',
                    meaning: row['意思'] || row['meaning'] || '',
                    example: row['例子'] || row['example'] || ''
                  }
                });
              });
            }
            if (!cancelled && aggregated.length) {
              addItems(aggregated, { overrideExamples: false, replace: true });
              try { localStorage.setItem(LS.presetApplied, PRESET_VERSION); } catch {}
            }
          };
          ensureCsvPreset();
          return () => { cancelled = true; };
        }, []);

        return { data, addItems, reset };
      };

      const useFavorites = () => {
        const [favorites, setFavorites] = useState(() => {
          try {
            const raw = localStorage.getItem(LS.favorites);
            return raw ? JSON.parse(raw) : [];
          } catch {
            return [];
          }
        });
        useEffect(() => {
          try { localStorage.setItem(LS.favorites, JSON.stringify(favorites)); } catch {}
        }, [favorites]);
        return {
          favorites,
          toggle: (id) => setFavorites((cur) => cur.includes(id) ? cur.filter((x) => x !== id) : [...cur, id]),
          remove: (id) => setFavorites((cur) => cur.filter((x) => x !== id)),
          clear: () => setFavorites([])
        };
      };

      // 管理使用者自訂例句的 hook
      const useUserExamples = () => {
        const [userExamples, setUserExamples] = useState(() => {
          try {
            const raw = localStorage.getItem(LS.userExamples);
            return raw ? JSON.parse(raw) : {};
          } catch {
            return {};
          }
        });
        
        useEffect(() => {
          try { 
            localStorage.setItem(LS.userExamples, JSON.stringify(userExamples)); 
          } catch (e) {
            console.error('無法儲存使用者例句:', e);
          }
        }, [userExamples]);
        
        return {
          // 取得某個單字的使用者例句
          get: (wordId) => {
            return userExamples[wordId] || [];
          },
          // 新增例句
          add: (wordId, sentence, translation) => {
            setUserExamples((cur) => {
              const existing = cur[wordId] || [];
              return {
                ...cur,
                [wordId]: [...existing, { 
                  sentence: sentence.trim(), 
                  translation: translation.trim(),
                  source: 'user',
                  createdAt: new Date().toISOString()
                }]
              };
            });
          },
          // 刪除例句
          remove: (wordId, exampleIndex) => {
            setUserExamples((cur) => {
              const existing = cur[wordId] || [];
              const updated = existing.filter((_, idx) => idx !== exampleIndex);
              if (updated.length === 0) {
                const newState = { ...cur };
                delete newState[wordId];
                return newState;
              }
              return { ...cur, [wordId]: updated };
            });
          },
          // 清空某個單字的所有使用者例句
          clearWord: (wordId) => {
            setUserExamples((cur) => {
              const newState = { ...cur };
              delete newState[wordId];
              return newState;
            });
          },
          // 清空所有使用者例句
          clearAll: () => {
            setUserExamples({});
          }
        };
      };

      const Importer = ({ onImport, className = "" }) => {
        const [msg, setMsg] = useState("");
        const [paste, setPaste] = useState("");
        const [dragOver, setDragOver] = useState(false);
        const [override, setOverride] = useState(true);
        const inputRef = useRef(null);

        const posSummary = (stats) => Object.entries(stats.tagsAdded || {}).map(([k, v]) => `${POS_LABEL[k] || k}:${v}`).join('、');

        const importText = async (rawText, hint) => {
          const text = String(rawText || "").replace(/^\uFEFF/, "").trim();
          if (!text) { setMsg("匯入失敗：內容為空"); return; }

          const tryJson = () => {
            try {
              const parsed = JSON.parse(text);
              if (Array.isArray(parsed)) {
                const stats = onImport(parsed, { overrideExamples: override, replace: false });
                const summary = posSummary(stats);
                setMsg(`已匯入 ${stats.added + stats.merged} 筆（${hint}JSON），新增單字 ${stats.added}，合併 ${stats.merged}${summary ? `，新增標籤 ${summary}` : ""}。`);
                return true;
              }
            } catch {}
            return false;
          };

          if (tryJson()) return;
          const rows = parseCSV(text);
          if (!rows.length) { setMsg("匯入失敗：內容不是有效的 JSON 或 CSV"); return; }
          const stats = onImport(rows, { overrideExamples: override, replace: false });
          const summary = posSummary(stats);
          setMsg(`已匯入 ${stats.added + stats.merged} 筆（${hint}CSV），新增單字 ${stats.added}，合併 ${stats.merged}${summary ? `，新增標籤 ${summary}` : ""}。`);
        };

        const onInputChange = (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => { importText(reader.result, `${file.name}/`); };
          reader.onerror = () => { setMsg(`匯入失敗：無法讀取檔案 ${file.name}`); };
          reader.readAsText(file);
          e.target.value = "";
        };

        const onDrop = (e) => {
          e.preventDefault();
          setDragOver(false);
          const file = e.dataTransfer?.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => { importText(reader.result, `${file.name}/`); };
          reader.onerror = () => { setMsg(`匯入失敗：無法讀取檔案 ${file.name}`); };
          reader.readAsText(file);
        };

        return (
          <div
            className={`rounded-2xl border p-4 bg-white/60 ${dragOver ? 'ring-2 ring-indigo-400' : ''} ${className}`}
            onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
            onDragLeave={() => setDragOver(false)}
            onDrop={onDrop}
          >
            <div className="font-semibold mb-2">資料匯入（JSON/CSV）</div>
            <p className="text-sm text-gray-600 mb-3">三種方式：① 選擇檔案 ② 拖曳到此區 ③ 直接貼上文字</p>

            <div className="flex flex-wrap items-center gap-3 mb-3">
              <input ref={inputRef} type="file" accept="application/json,.json,.csv,text/csv,text/plain" className="hidden" onChange={onInputChange} />
              <Button variant="ghost" onClick={() => inputRef.current?.click()}>選擇 JSON 或 CSV 檔</Button>
              <label className="flex items-center gap-1 text-xs text-gray-600">
                <input type="checkbox" className="mr-1" checked={override} onChange={(e) => setOverride(e.target.checked)} />
                匯入例句／翻譯時覆蓋現有內容
              </label>
              <span className="text-xs text-gray-500">或拖曳檔案至此</span>
            </div>

            <div className="mt-2">
              <textarea
                value={paste}
                onChange={(e) => setPaste(e.target.value)}
                placeholder="或直接貼上 JSON / CSV 文字..."
                className="w-full h-28 px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              />
              <div className="mt-2">
                <Button variant="ghost" onClick={() => importText(paste, '貼上/')}>匯入貼上的內容</Button>
              </div>
            </div>

          {msg && <div className="text-xs text-gray-500 mt-2">{msg}</div>}
        </div>
        );
      };

      const Shell = ({ children, onReset }) => {
        return (
          <div className="min-h-screen bg-gradient-to-b from-indigo-50 to-white">
            <div className="max-w-5xl mx-auto px-4 py-6">
              <header className="flex items-center justify-between mb-6">
                <a href="#/" className="text-2xl font-bold tracking-tight">Vocabulary MVP v4.2</a>
                <nav className="flex gap-2 items-center">
                  <a href="#/" className="px-3 py-2 rounded-lg hover:bg-gray-100">首頁</a>
                  <a href="#/favorites" className="px-3 py-2 rounded-lg hover:bg-gray-100">我的最愛</a>
                  <a href="#/quiz" className="px-3 py-2 rounded-lg hover:bg-gray-100">填空測驗</a>
                  <Button variant="ghost" onClick={onReset}>重置資料</Button>
                </nav>
              </header>
              {children}
              <footer className="mt-12 text-center text-xs text-gray-400">MVP demo • Local-only • v4.2（高中-匯入版）</footer>
            </div>
          </div>
        );
      };

      const Home = ({ push, data, onImport }) => {
        const saved = useMemo(() => {
          try { return JSON.parse(localStorage.getItem(LS.homeFilters) || '{}'); } catch { return {}; }
        }, []);
        const [q, setQ] = useState(saved.q || "");
        const [selectedTheme, setSelectedTheme] = useState(saved.theme || "all");
        const [selectedPOS, setSelectedPOS] = useState(saved.pos || "all");
        const [selectedLevels, setSelectedLevels] = useState(saved.levels || []);
        useEffect(() => {
          try { localStorage.setItem(LS.homeFilters, JSON.stringify({ q, theme: selectedTheme, pos: selectedPOS, levels: selectedLevels })); } catch {}
        }, [q, selectedTheme, selectedPOS, selectedLevels]);
        
        const themes = useMemo(() => ALL_THEMES.map(k => ({ 
          key: k, 
          count: data.filter((w) => {
            // 檢查是否有對應的主題
            if (wordHasTheme(w, k)) return true;
            // 特別處理 highschool_climate 主題，檢查是否有「氣候」主題
            if (k === 'highschool_climate') {
              const wordThemes = getWordThemes(w);
              return wordThemes.includes('氣候') || wordThemes.includes('climate');
            }
            return false;
          }).length 
        })), [data]);
        const levels = useMemo(() => {
          const set = new Set();
          data.forEach((w)=>{ const lv = String(w.level||'').trim(); if(lv) set.add(lv); });
          return Array.from(set).sort((a,b)=> String(a).localeCompare(String(b)));
        }, [data]);

        const themeFilteredData = useMemo(() => {
          if (selectedTheme === "all") return data;
          const filtered = data.filter((w) => {
            // 檢查是否有對應的主題
            if (wordHasTheme(w, selectedTheme)) return true;
            // 特別處理 highschool_climate 主題，檢查是否有「氣候」主題
            if (selectedTheme === 'highschool_climate') {
              const wordThemes = getWordThemes(w);
              return wordThemes.includes('氣候') || wordThemes.includes('climate');
            }
            return false;
          });
          return [...filtered].sort((a, b) => {
            const orderA = a?.theme_order?.[selectedTheme];
            const orderB = b?.theme_order?.[selectedTheme];
            const safeA = Number.isFinite(orderA) ? orderA : Number.MAX_SAFE_INTEGER;
            const safeB = Number.isFinite(orderB) ? orderB : Number.MAX_SAFE_INTEGER;
            if (safeA !== safeB) return safeA - safeB;
            return String(a.english_word || '').localeCompare(String(b.english_word || ''));
          });
        }, [data, selectedTheme]);

        const categories = useMemo(() => ALL_POS.map(k => ({ key:k, count: themeFilteredData.filter(w=> (w.posTags||[]).includes(k)).length })), [themeFilteredData]);
        const totalForTheme = themeFilteredData.length;

        const filtered = useMemo(() => { 
          const s=q.trim().toLowerCase(); 
          let filteredData = themeFilteredData;
          
          if (selectedPOS !== "all") {
            filteredData = filteredData.filter(w => (w.posTags||[]).includes(selectedPOS));
          }
          if (selectedLevels.length > 0) {
            filteredData = filteredData.filter(w => selectedLevels.includes(String(w.level||'').trim()));
          }
          
          if(!s) return filteredData; 
          return filteredData.filter(w=>w.english_word.toLowerCase().includes(s)); 
        }, [q, themeFilteredData, selectedPOS, selectedLevels]);
        const selectedPosCount = useMemo(() => {
          if (selectedPOS === "all") return totalForTheme;
          const match = categories.find((c) => c.key === selectedPOS);
          return match ? match.count : 0;
        }, [categories, selectedPOS, totalForTheme]);
        const themeLabel = selectedTheme === "all" ? "全部主題" : (THEME_LABEL[selectedTheme] || selectedTheme);
        const posLabel = selectedPOS === "all" ? `全部詞性 (${totalForTheme})` : `${POS_LABEL[selectedPOS] || selectedPOS} (${selectedPosCount})`;
        const levelLabel = selectedLevels.length === 0 ? "全部 Level" : `Level ${selectedLevels.join(', ')}`;
        const ensureLine = (text) => {
          const t = String(text || '').trim();
          return t ? t : '\u00A0';
        };
        const showTable = filtered.length > 0;
        return (
          <div>
            <p className="text-gray-600 mb-6">歡迎來到單字索引庫，請從主題或詞性選擇您想要的單字。</p>

            <div className="grid gap-4 lg:grid-cols-4 mb-8">
              <div className="rounded-2xl border p-4 bg-white/70">
                <h2 className="text-lg font-semibold mb-3">主題篩選</h2>
                <div className="flex flex-wrap gap-2">
                  <Button 
                    variant={selectedTheme === "all" ? "primary" : "ghost"} 
                    onClick={() => setSelectedTheme("all")}
                  >
                    全選 ({data.length})
                  </Button>
                  {themes.map(t => (
                    <Button 
                      key={t.key} 
                      variant={selectedTheme === t.key ? "primary" : "ghost"} 
                      onClick={() => setSelectedTheme(t.key)}
                    >
                      {THEME_LABEL[t.key]} ({t.count})
                    </Button>
                  ))}
                </div>
              </div>

              <div className="rounded-2xl border p-4 bg-white/70">
                <h2 className="text-lg font-semibold mb-3">詞性篩選</h2>
                <div className="flex flex-wrap gap-2">
                  <Button 
                    variant={selectedPOS === "all" ? "primary" : "ghost"} 
                    onClick={() => setSelectedPOS("all")}
                  >
                    全選 ({totalForTheme})
                  </Button>
                  {categories.filter(c => c.count > 0).map(c => (
                    <Button 
                      key={c.key} 
                      variant={selectedPOS === c.key ? "primary" : "ghost"} 
                      onClick={() => setSelectedPOS(c.key)}
                    >
                      {POS_LABEL[c.key]} ({c.count})
                    </Button>
                  ))}
                </div>
              </div>

              <div className="rounded-2xl border p-4 bg-white/70">
                <h2 className="text-lg font-semibold mb-3">Level 篩選</h2>
                <div className="flex flex-wrap gap-2">
                  <Button 
                    variant={selectedLevels.length === 0 ? "primary" : "ghost"} 
                    onClick={() => setSelectedLevels([])}
                  >
                    全選 ({totalForTheme})
                  </Button>
                  {levels.map((lv)=> (
                    <Button 
                      key={lv} 
                      variant={selectedLevels.includes(lv) ? "primary" : "ghost"} 
                      onClick={() => {
                        if (selectedLevels.includes(lv)) {
                          setSelectedLevels(selectedLevels.filter(l => l !== lv));
                        } else {
                          setSelectedLevels([...selectedLevels, lv]);
                        }
                      }}
                    >
                      {lv} ({themeFilteredData.filter(w => String(w.level||'').trim() === lv).length})
                    </Button>
                  ))}
                </div>
              </div>

              <Importer onImport={onImport} className="h-full bg-white" />
            </div>

            <div className="mb-3 flex items-center gap-3">
              <input value={q} onChange={(e)=>setQ(e.target.value)} placeholder="搜尋單字..." className="w-full md:w-1/2 px-4 py-2 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500" />
            </div>
            <div className="mt-6 space-y-4">
              <div className="flex flex-wrap items-baseline justify-between gap-3">
                <div>
                  <h2 className="text-xl font-semibold">{themeLabel} · {posLabel} · {levelLabel}</h2>
                  <p className="text-sm text-gray-500">符合條件的單字：{filtered.length} 筆{q ? `（含搜尋「${q}」）` : ''}</p>
                </div>
                {(selectedTheme !== "all" || selectedPOS !== "all" || selectedLevels.length > 0 || q) && (
                  <Button variant="ghost" onClick={()=>{ setSelectedTheme("all"); setSelectedPOS("all"); setSelectedLevels([]); setQ(""); }}>清除篩選</Button>
                )}
              </div>
              <div className="overflow-x-auto rounded-2xl border border-gray-200 bg-white/80 shadow-sm">
                {!showTable ? (
                  <p className="px-4 py-6 text-sm text-gray-500">找不到符合條件的單字，請調整主題、詞性或搜尋條件。</p>
                ) : (
                  <table className="min-w-full text-sm">
                    <thead className="bg-indigo-50 text-xs uppercase tracking-wide text-indigo-700">
                      <tr>
                        <th className="px-4 py-3 text-left font-semibold">Level</th>
                        <th className="px-4 py-3 text-left font-semibold">單字</th>
                        <th className="px-4 py-3 text-left font-semibold">音標</th>
                        <th className="px-4 py-3 text-left font-semibold">中譯</th>
                        <th className="px-4 py-3 text-left font-semibold">例句</th>
                        <th className="px-4 py-3 text-left font-semibold">翻譯</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-gray-200">
                      {filtered.map((w) => {
                        const posText = (w.posTags||[]).map(p=>POS_LABEL[p]||p).join('、') || '—';
                        const examples = [ensureLine(w.example_sentence), ensureLine(w.example_sentence_2)];
                        const translations = [ensureLine(w.example_translation), ensureLine(w.example_translation_2)];
                        const themeLabels = getThemeDisplayLabels(w);
                        const themeDisplay = themeLabels.length ? themeLabels.join(' / ') : '—';
                        return (
                          <tr key={w.id} className="align-top">
                            <td className="px-4 py-4 whitespace-nowrap align-top text-center">
                              <span className="inline-flex items-center justify-center w-8 h-8 rounded-full bg-indigo-100 text-indigo-700 font-semibold text-sm">
                                {w.level || '—'}
                              </span>
                            </td>
                            <td className="px-4 py-4 whitespace-nowrap align-top">
                              <a href={`#/word/${w.id}`} className="text-base font-semibold text-indigo-700 hover:underline">
                                {w.english_word}
                              </a>
                              <div className="mt-1 text-xs text-gray-500">{posText}</div>
                              <div className="mt-1 text-xs text-gray-400">{themeDisplay}</div>
                            </td>
                            <td className="px-4 py-4 whitespace-nowrap align-top text-gray-700">{w.kk_phonetic || '—'}</td>
                            <td className="px-4 py-4 align-top text-gray-800 whitespace-pre-wrap">{w.chinese_definition || '—'}</td>
                            <td className="px-4 py-4 align-top text-gray-700">
                              {examples.map((line, idx) => (
                                <div key={`ex-${w.id}-${idx}`} className="min-h-[1.5rem] whitespace-pre-wrap leading-relaxed">
                                  {line}
                                </div>
                              ))}
                            </td>
                            <td className="px-4 py-4 align-top text-gray-700">
                              {translations.map((line, idx) => (
                                <div key={`tr-${w.id}-${idx}`} className="min-h-[1.5rem] whitespace-pre-wrap leading-relaxed">
                                  {line}
                                </div>
                              ))}
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                )}
              </div>
            </div>
          </div>
        );
      };

      const CategoryList = ({ cat, data }) => {
        const list = data.filter(w => (w.posTags||[]).includes(cat));
        return (
          <div>
            <h1 className="text-2xl font-bold mb-4">{POS_LABEL[cat] || cat || '—'}（{list.length}）</h1>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
              {list.map(w => (
                <a key={w.id} href={`#/word/${w.id}`} className="block rounded-xl border p-3 hover:shadow">
                  <div className="font-semibold">{w.english_word}</div>
                  <div className="text-xs text-gray-500">{(w.posTags||[]).join(', ')}</div>
                </a>
              ))}
            </div>
          </div>
        );
      };

      const WordDetail = ({ id, data, favoritesApi, userExamplesApi, push, prevRoute }) => {
        const word = data.find((w) => String(w.id) === String(id));
        const [selPos, setSelPos] = useState(word?.posTags?.[0] || "other");
        const [mdPreview, setMdPreview] = useState('');
        const [mdStatus, setMdStatus] = useState('');
        const [showMdPreview, setShowMdPreview] = useState(false);
        const [exportSections, setExportSections] = useState({ pos: true, relations: true, affix: true });
        const [showAddExample, setShowAddExample] = useState(false);
        const [newExampleEn, setNewExampleEn] = useState('');
        const [newExampleZh, setNewExampleZh] = useState('');

        // 合併 CSV 和使用者例句的函數
        const getAllExamples = (word) => {
          const examples = [];
          
          // 除錯：檢查 word 物件是否有例句3-5
          if (word.english_word === 'air' || word.english_word === 'fall' || word.english_word === 'blow') {
            console.log(`=== ${word.english_word} 例句檢查 ===`);
            console.log('example_sentence:', word.example_sentence);
            console.log('example_sentence_2:', word.example_sentence_2);
            console.log('example_sentence_3:', word.example_sentence_3);
            console.log('example_sentence_4:', word.example_sentence_4);
            console.log('example_sentence_5:', word.example_sentence_5);
          }
          
          // 從 CSV 讀取例句（1-5）
          for (let i = 1; i <= 5; i++) {
            const sentenceKey = i === 1 ? 'example_sentence' : `example_sentence_${i}`;
            const translationKey = i === 1 ? 'example_translation' : `example_translation_${i}`;
            
            const sentence = (word[sentenceKey] || '').trim();
            const translation = (word[translationKey] || '').trim();
            
            // 只要有任何一個欄位有內容就保留
            if (sentence || translation) {
              // 只有例句2有出處資訊
              const sourceInfo = (i === 2 && word.example_source_2) ? word.example_source_2.trim() : '';
              
              examples.push({
                sentence,
                translation,
                source: 'csv',
                sourceInfo,
                index: i
              });
            }
          }
          
          if (word.english_word === 'air' || word.english_word === 'fall' || word.english_word === 'blow') {
            console.log('收集到的例句數量:', examples.length);
            console.log('例句列表:', examples);
          }
          
          // 從 localStorage 讀取使用者例句
          const userExamples = userExamplesApi.get(word.id);
          userExamples.forEach((ex, idx) => {
            examples.push({
              sentence: ex.sentence,
              translation: ex.translation,
              source: 'user',
              sourceInfo: '',
              userIndex: idx
            });
          });
          
          // 限制最多 5 個
          return examples.slice(0, 5);
        };

        const allExamples = word ? getAllExamples(word) : [];
        const canAddMore = allExamples.length < 5;

        // 新增例句的處理函數
        const handleAddExample = () => {
          if (!newExampleEn.trim() && !newExampleZh.trim()) {
            alert('請至少輸入英文或中文例句');
            return;
          }
          userExamplesApi.add(word.id, newExampleEn, newExampleZh);
          setNewExampleEn('');
          setNewExampleZh('');
          setShowAddExample(false);
        };

        // 刪除例句的處理函數
        const handleDeleteExample = (example) => {
          if (example.source === 'user' && example.userIndex !== undefined) {
            if (confirm('確定要刪除這個例句嗎？')) {
              userExamplesApi.remove(word.id, example.userIndex);
            }
          }
        };

        useEffect(() => {
          setMdStatus('');
          setShowMdPreview(false);
          setMdPreview('');
          setShowAddExample(false);
          setNewExampleEn('');
          setNewExampleZh('');
        }, [selPos, word?.id]);

        useEffect(() => {
          setExportSections({ pos: true, relations: true, affix: true });
        }, [word?.id]);

        useEffect(() => {
          if (!word) return;
          const nextPos = Array.isArray(word.posTags) && word.posTags.length ? word.posTags[0] : 'other';
          setSelPos(nextPos);
        }, [word?.id]);

        if (!word) return <div>找不到單字。</div>;

        const posTags = Array.isArray(word.posTags) && word.posTags.length ? word.posTags : ['other'];
        const posTextFull = posTags.map((tag) => POS_LABEL[tag] || tag);
        const themeKeys = getWordThemes(word);
        const themeLabels = getThemeDisplayLabels(word);
        const primaryThemeLabel = themeLabels[0] || '—';
        const levelText = String(word.level ?? '').trim();
        const isFav = favoritesApi.favorites.includes(word.id);

        const auto = grammarDefaults(word.english_word, selPos, word.grammar_sub_category);
        const gFunc = (word.grammar_function || '').trim() || auto.grammar_function;
        const gPattern = (word.applicable_sentence_pattern || '').trim() || auto.sentence_pattern;

        const wfDetailRaw = word.word_forms_detail || emptyWordFormsDetail();
        const wfDetail = {
          base: Array.isArray(wfDetailRaw.base) ? wfDetailRaw.base : [],
          idiom: Array.isArray(wfDetailRaw.idiom) ? wfDetailRaw.idiom : [],
          compound: Array.isArray(wfDetailRaw.compound) ? wfDetailRaw.compound : [],
          derivation: Array.isArray(wfDetailRaw.derivation) ? wfDetailRaw.derivation : []
        };
        
        // 詞性變化資料會在渲染時直接顯示

        const clean = (value) => String(value || '').trim();
        const primaryExampleEn = clean(word.example_sentence);
        const primaryExampleZh = clean(word.example_translation);
        const secondaryExampleEn = clean(word.example_sentence_2);
        const secondaryExampleZh = clean(word.example_translation_2);
        const secondaryExampleSource = clean(word.example_source_2);
        
        // 除錯：檢查資料載入狀況
        if (word.english_word === 'air') {
          console.log('Air 單字資料檢查:', {
            english_word: word.english_word,
            example_sentence: word.example_sentence,
            example_sentence_2: word.example_sentence_2,
            example_source_2: word.example_source_2,
            secondaryExampleSource: secondaryExampleSource,
            rawData: word
          });
        }
        const fallbackExample = exampleFor(word.english_word, selPos);
        const fallbackTranslation = translationFor(word.english_word, selPos);

        const exampleCards = [
          { en: primaryExampleEn, zh: primaryExampleZh, allowFallback: true, source: '' },
          { en: secondaryExampleEn, zh: secondaryExampleZh, allowFallback: false, source: secondaryExampleSource }
        ];

        const synonyms = Array.isArray(word.synonyms) ? word.synonyms : multiSplit(word.synonyms || '');
        const antonyms = Array.isArray(word.antonyms) ? word.antonyms : multiSplit(word.antonyms || '');
        const confusables = Array.isArray(word.confusables) ? word.confusables : multiSplit(word.confusables || '');
        const hasSynonymBlock = synonyms.length || antonyms.length || confusables.length;

        const affix = word.affix_info || {};
        const affixInfo = {
          prefix: clean(affix.prefix),
          root: clean(affix.root),
          suffix: clean(affix.suffix),
          meaning: clean(affix.meaning),
          example: clean(affix.example)
        };
        const hasAffixInfo = affixInfo.prefix || affixInfo.suffix || affixInfo.root;

        const exportExample1 = primaryExampleEn || fallbackExample;
        const exportTranslation1 = primaryExampleZh || fallbackTranslation;
        const exportExample2 = secondaryExampleEn;
        const exportTranslation2 = secondaryExampleZh;

        const handleOutput = async () => {
          const md = wordToMarkdown(word, selPos, {
            example_sentence: exportExample1,
            example_translation: exportTranslation1,
            example_sentence_2: exportExample2,
            example_translation_2: exportTranslation2,
            grammar_function: gFunc,
            applicable_sentence_pattern: gPattern,
            grammar_sub_category: word.grammar_sub_category,
            word_forms: word.word_forms,
            derivatives: word.derivatives,
            synonyms: word.synonyms,
            antonyms: word.antonyms,
            confusables: word.confusables,
            affix_info: word.affix_info,
            sections: exportSections
          });
          setMdPreview(md);
          if (!md || !md.trim()) {
            setMdStatus('此單字目前沒有可輸出的內容。');
            setShowMdPreview(false);
            return;
          }
          try {
            if (navigator && navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(md);
              setMdStatus('已複製 Markdown，可貼到 Google 文件或投影片。');
              setShowMdPreview(false);
              return;
            }
            throw new Error('clipboard not available');
          } catch (err) {
            setMdStatus('無法自動複製，請手動複製下方內容。');
            setShowMdPreview(true);
          }
        };

        const goBack = () => {
          if (prevRoute && prevRoute.route) {
            if (prevRoute.route === 'category' && prevRoute.param) { push(`#/category/${prevRoute.param}`); return; }
            if (prevRoute.route === 'favorites') { push('#/favorites'); return; }
            if (prevRoute.route === 'quiz') { push('#/quiz'); return; }
            if (prevRoute.route === 'word' && prevRoute.param) { push(`#/word/${prevRoute.param}`); return; }
            if (prevRoute.route === 'home') { push('#/'); return; }
          }
          push('#/');
        };

        // 解析來源資訊
        const formatSource = (source) => {
          if (!source) return '';
          const parts = source.split('\t');
          if (parts.length === 3) {
            return `${parts[0]} ${parts[1]} ${parts[2]}`;
          }
          return source;
        };

        const renderExampleCard = (example, idx) => {
          const fallbackExample = exampleFor(word.english_word, selPos);
          const fallbackTranslation = translationFor(word.english_word, selPos);
          
          // 第一個例句如果為空可以使用 fallback
          const useFallback = idx === 0 && !example.sentence;
          const enText = example.sentence || (useFallback ? fallbackExample : '');
          const zhText = example.translation || (useFallback ? fallbackTranslation : '');
          const speakText = enText;
          
          // 如果沒有內容就不顯示
          if (!enText && !zhText && !useFallback) {
            return null;
          }
          
          return (
            <div key={`example-${idx}`} className="rounded-2xl bg-indigo-50 px-4 py-3 relative">
              <div className="flex items-start gap-2">
                <div className="flex-1 text-base text-gray-900 whitespace-pre-wrap">{enText || ' '}</div>
                <div className="flex items-center gap-2">
                  {speakText ? (
                    <SpeakerButton
                      onClick={() => speak(speakText)}
                      label={`播放例句 ${idx + 1} 發音`}
                      className="mt-0.5"
                    />
                  ) : null}
                  {example.source === 'user' && (
                    <button
                      onClick={() => handleDeleteExample(example)}
                      className="h-8 w-8 rounded-full border border-rose-200 bg-white text-rose-600 hover:bg-rose-50 hover:text-rose-700 transition flex items-center justify-center"
                      title="刪除例句"
                    >
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className="h-4 w-4">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  )}
                </div>
              </div>
              <div className="mt-2 text-sm text-indigo-800 whitespace-pre-wrap">{zhText || ' '}</div>
              {useFallback && (
                <div className="mt-2 text-xs text-gray-500">（系統預設例句，尚未補入原始資料）</div>
              )}
              {example.source === 'user' && (
                <div className="mt-2 text-xs text-emerald-600 font-medium">✏️ 我的例句</div>
              )}
              {/* 例句1：顯示「基礎例句」 */}
              {example.source === 'csv' && example.index === 1 && (
                <div className="mt-2 text-xs text-gray-500 text-right">基礎例句</div>
              )}
              {/* 例句2：顯示 CSV 出處 */}
              {example.source === 'csv' && example.index === 2 && example.sourceInfo && (
                <div className="mt-2 text-xs text-gray-500 text-right">{formatSource(example.sourceInfo)}</div>
              )}
            </div>
          );
        };

        const renderTagPill = (items, classes) => (
          <div className="flex flex-wrap gap-2">
            {items.map((item, idx) => (
              <span key={`${classes}-${idx}`} className={`px-3 py-1 rounded-full ${classes}`}>{item}</span>
            ))}
          </div>
        );

        const toggleExportSection = (key) => {
          setExportSections((prev) => ({ ...prev, [key]: !prev[key] }));
        };

        return (
          <div className="space-y-6">
              <div className="flex flex-wrap items-center justify-between gap-3">
                <div className="flex items-center gap-2">
                  <Button variant="ghost" onClick={goBack}>← 返回</Button>
                  <span className="text-xs text-gray-500">{themeLabels.length ? themeLabels.join(' / ') : '—'}</span>
                </div>
                <div className="flex gap-2">
                  <Button variant={isFav ? 'danger' : 'primary'} onClick={() => favoritesApi.toggle(word.id)}>{isFav ? '移除最愛' : '加入最愛'}</Button>
                </div>
              </div>

            <div className="rounded-3xl border border-gray-200 bg-white/90 p-6 shadow-sm space-y-6">
              <div>
                <div className="flex items-center gap-3">
                  <h1 className="text-4xl font-bold text-gray-900">{word.english_word}</h1>
                  <SpeakerButton label="播放單字發音" onClick={() => speak(word.english_word)} />
                </div>
                <div className="mt-3 flex flex-wrap items-center gap-2 text-sm text-gray-600">
                  <span className="rounded-full bg-indigo-50 px-3 py-1 text-indigo-600">{POS_LABEL[selPos] || selPos}</span>
                  {levelText && <span className="rounded-full bg-amber-50 px-3 py-1 text-amber-600">Level {levelText}</span>}
                  {word.cefr && <span className="rounded-full bg-purple-50 px-3 py-1 text-purple-600">{word.cefr}</span>}
                  {themeLabels.map((label, idx) => (
                    <span key={`theme-${idx}`} className="rounded-full bg-gray-100 px-3 py-1 text-gray-600">{label}</span>
                  ))}
                  {word.grammar_sub_category && <span className="rounded-full bg-emerald-50 px-3 py-1 text-emerald-600">{word.grammar_sub_category}</span>}
                </div>
                {word.kk_phonetic && <div className="mt-4 text-lg font-medium text-indigo-700">{word.kk_phonetic}</div>}
                {posTags.length > 1 && (
                  <div className="mt-4 flex flex-wrap gap-2 text-xs">
                    {posTags.map((tag) => (
                      <button
                        key={tag}
                        onClick={() => setSelPos(tag)}
                        className={`px-3 py-1 rounded-full border transition ${selPos === tag ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white text-gray-600 border-gray-200 hover:border-indigo-400'}`}
                      >
                        {POS_LABEL[tag] || tag}
                      </button>
                    ))}
                  </div>
                )}
              </div>

              <div>
                <div className="text-sm font-semibold text-gray-500 uppercase tracking-wide">中譯</div>
                <div className="mt-2 text-lg text-gray-900 whitespace-pre-wrap">{word.chinese_definition || '—'}</div>
              </div>

              <div>
                <div className="flex items-center justify-between mb-3">
                  <div className="text-sm font-semibold text-gray-500 uppercase tracking-wide">
                    例句 ({allExamples.length}/5)
                  </div>
                  {canAddMore && !showAddExample && (
                    <button
                      onClick={() => setShowAddExample(true)}
                      className="px-3 py-1 text-sm rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition flex items-center gap-1"
                    >
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className="h-4 w-4">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                      </svg>
                      新增例句
                    </button>
                  )}
                </div>
                
                <div className="space-y-3">
                  {allExamples.map((example, idx) => renderExampleCard(example, idx))}
                  
                  {showAddExample && (
                    <div className="rounded-2xl border-2 border-indigo-300 bg-indigo-50/50 px-4 py-4 space-y-3">
                      <div className="flex items-center justify-between mb-2">
                        <div className="text-sm font-semibold text-indigo-700">新增自訂例句</div>
                        <button
                          onClick={() => setShowAddExample(false)}
                          className="text-gray-500 hover:text-gray-700"
                        >
                          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" className="h-5 w-5">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                          </svg>
                        </button>
                      </div>
                      <div>
                        <label className="block text-sm text-gray-700 mb-1">英文例句</label>
                        <input
                          type="text"
                          value={newExampleEn}
                          onChange={(e) => setNewExampleEn(e.target.value)}
                          placeholder="輸入英文例句..."
                          className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        />
                      </div>
                      <div>
                        <label className="block text-sm text-gray-700 mb-1">中文翻譯</label>
                        <input
                          type="text"
                          value={newExampleZh}
                          onChange={(e) => setNewExampleZh(e.target.value)}
                          placeholder="輸入中文翻譯..."
                          className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        />
                      </div>
                      <div className="flex gap-2 justify-end">
                        <button
                          onClick={() => setShowAddExample(false)}
                          className="px-4 py-2 rounded-lg border border-gray-300 text-gray-700 hover:bg-gray-50 transition"
                        >
                          取消
                        </button>
                        <button
                          onClick={handleAddExample}
                          className="px-4 py-2 rounded-lg bg-indigo-600 text-white hover:bg-indigo-700 transition"
                        >
                          儲存
                        </button>
                      </div>
                    </div>
                  )}
                  
                  {allExamples.length === 0 && (
                    <div className="text-gray-500 text-sm py-4 text-center">
                      目前沒有例句，點擊「新增例句」來新增第一個例句
                    </div>
                  )}
                </div>
              </div>
            </div>

            <div className="space-y-4">
              <section className="rounded-2xl border border-gray-200 bg-white/80 p-5">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  {/* 左欄：詞性 */}
                  <div>
                    <h2 className="text-lg font-semibold text-gray-800 mb-3">詞性</h2>
                    <div className="text-base text-gray-700">
                      {String(word.word_forms || word['詞性變化'] || '').split('\n').map((line, idx, arr) => (
                        <React.Fragment key={idx}>
                          {line}
                          {idx < arr.length - 1 && <br />}
                        </React.Fragment>
                      ))}
                    </div>
                  </div>
                  
                  {/* 右欄：片語 */}
                  {Array.isArray(word.phrases) && word.phrases.length > 0 && (
                    <div>
                      <h2 className="text-lg font-semibold text-gray-800 mb-3">片語</h2>
                      <div className="flex flex-wrap gap-2">
                        {word.phrases.map((phrase, idx) => (
                          <span key={`phrase-${idx}`} className="px-4 py-2 text-base font-semibold rounded-lg bg-purple-100 text-purple-700 border border-purple-300 shadow-sm">{phrase}</span>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </section>

              {hasSynonymBlock ? (
                <section className="rounded-2xl border border-gray-200 bg-white/80 p-5">
                  <h2 className="text-lg font-semibold text-gray-800 mb-3">同義／反義／易混淆</h2>
                  <div className="grid gap-4 md:grid-cols-3 text-base text-gray-700">
                    {synonyms.length ? (
                      <div>
                        <div className="text-sm font-semibold text-gray-500 mb-1">同義字</div>
                        {renderTagPill(synonyms, 'bg-blue-50 text-blue-600 text-base')}
                      </div>
                    ) : null}
                    {antonyms.length ? (
                      <div>
                        <div className="text-sm font-semibold text-gray-500 mb-1">反義字</div>
                        {renderTagPill(antonyms, 'bg-rose-50 text-rose-600 text-base')}
                      </div>
                    ) : null}
                    {confusables.length ? (
                      <div>
                        <div className="text-sm font-semibold text-gray-500 mb-1">易混淆字</div>
                        {renderTagPill(confusables, 'bg-amber-50 text-amber-600 text-base')}
                      </div>
                    ) : null}
                  </div>
                </section>
              ) : null}

              {hasAffixInfo ? (
                <section className="rounded-2xl border border-gray-200 bg-white/80">
                  <details>
                    <summary className="cursor-pointer list-none px-5 py-4 text-lg font-semibold text-gray-800 flex items-center gap-2">
                      {(() => {
                        const availableItems = [];
                        if (affixInfo.prefix) availableItems.push('字首');
                        if (affixInfo.suffix) availableItems.push('字尾');
                        if (affixInfo.root) availableItems.push('字根');
                        return availableItems.join('｜') || '字首｜字尾｜字根';
                      })()}
                      <span className="inline-flex h-5 w-5 items-center justify-center rounded-full border border-gray-300 text-gray-500 text-xs"></span>
                    </summary>
                    <div className="px-5 pb-5">
                      <div className="text-base text-gray-700">
                        <div className="mb-2 text-gray-900">{(() => {
                          const availableItems = [];
                          if (affixInfo.prefix) availableItems.push('字首');
                          if (affixInfo.suffix) availableItems.push('字尾');
                          if (affixInfo.root) availableItems.push('字根');
                          return availableItems.join('｜') || '字首｜字尾｜字根';
                        })()}</div>
                        <div className="grid gap-4 md:grid-cols-2">
                          {affixInfo.prefix && (
                            <div>
                              <div className="text-xs text-gray-500">字首</div>
                              <div className="mt-1 text-gray-900">{affixInfo.prefix}</div>
                            </div>
                          )}
                          {affixInfo.suffix && (
                            <div>
                              <div className="text-xs text-gray-500">字尾</div>
                              <div className="mt-1 text-gray-900">{affixInfo.suffix}</div>
                            </div>
                          )}
                          {affixInfo.root && (
                            <div className="md:col-span-2">
                              <div className="text-xs text-gray-500">字根</div>
                              <div className="mt-1 text-gray-900">{affixInfo.root}</div>
                            </div>
                          )}
                          <div className="md:col-span-2">
                            <div className="text-xs text-gray-500">意思</div>
                            <div className="mt-1 text-gray-900 whitespace-pre-wrap">{affixInfo.meaning || '—'}</div>
                          </div>
                          <div className="md:col-span-2">
                            <div className="text-xs text-gray-500">例子</div>
                            <div className="mt-1 text-gray-900 whitespace-pre-wrap">{affixInfo.example || '—'}</div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </details>
                </section>
              ) : null}
            </div>

            <div className="rounded-2xl border border-gray-200 bg-white/80">
              <details>
                <summary className="cursor-pointer list-none px-4 py-3 text-lg font-semibold text-gray-800 flex items-center gap-2">
                  匯出內容
                  <span className="inline-flex h-5 w-5 items-center justify-center rounded-full border border-gray-300 text-gray-500 text-xs"></span>
                </summary>
                <div className="px-4 pb-4 flex flex-wrap gap-4 text-sm text-gray-700">
                {[
                  { key: 'pos', label: '詞性區塊' },
                  { key: 'relations', label: '同義／反義／易混淆' },
                  { key: 'affix', label: '字根字首字尾' }
                ].map((opt) => (
                  <label key={opt.key} className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      checked={!!exportSections[opt.key]}
                      onChange={() => toggleExportSection(opt.key)}
                      className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                    />
                    <span>{opt.label}</span>
                  </label>
                ))}
                  <div className="flex justify-end gap-2 pt-2 w-full">
                    <Button variant="ghost" onClick={handleOutput}>匯出 Markdown</Button>
                  </div>
                </div>
              </details>
            </div>
            {mdStatus && <div className="text-sm text-gray-500 text-right">{mdStatus}</div>}
            {showMdPreview && (
              <div className="mt-3">
                <textarea value={mdPreview} readOnly className="w-full h-32 md:h-40 px-3 py-2 rounded-lg border border-gray-300 text-xs font-mono bg-white/80" />
                <div className="mt-1 text-xs text-gray-400 text-right">選取並複製後即可貼到 Google 文件／投影片。</div>
              </div>
            )}
          </div>
        );
      };

      const escapeForRegex = (s) => String(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const makeCloze = (sentence, answer) => {
        const esc = escapeForRegex(answer);
        const rx = new RegExp(`(^|[^A-Za-z])(${esc})(?=[^A-Za-z]|$)`, 'i');
        return String(sentence).replace(rx, (m) => m.replace(new RegExp(esc, 'i'), '_____ '));
      };

      const FavoritesPage = ({ favoritesApi, data }) => {
        const items = data.filter((w) => favoritesApi.favorites.includes(w.id));
        return (
          <div>
            <div className="flex items-center justify-between">
              <h1 className="text-2xl font-bold">我的最愛（{items.length}）</h1>
              <div className="flex gap-2">
                <a href="#/quiz?source=favorites"><Button>開始測驗</Button></a>
                {items.length>0 && <Button variant="ghost" onClick={favoritesApi.clear}>全部清除</Button>}
              </div>
            </div>
            {items.length === 0 ? (
              <p className="text-gray-600 mt-3">尚未加入任何單字。前往單字頁按「加入最愛」。</p>
            ) : (
              <div className="grid grid-cols-2 md:grid-cols-3 gap-3 mt-4">
                {items.map((w) => (
                  <div key={w.id} className="rounded-xl border p-3">
                    <a className="font-semibold hover:underline" href={`#/word/${w.id}`}>{w.english_word}</a>
                    <div className="text-xs text-gray-500 mb-2">{(w.posTags||[]).join(', ')}</div>
                    <Button variant="ghost" onClick={()=>favoritesApi.remove(w.id)}>移除</Button>
                  </div>
                ))}
              </div>
            )}
          </div>
        );
      };

      const QuizPage = ({ favoritesApi, hash, data }) => {
        const params = useMemo(() => Object.fromEntries(new URLSearchParams((hash.split('?')[1]||''))), [hash]);
        const source = params.source || 'all';
        const pool = useMemo(() => {
          if (source === 'favorites') {
            const ids=new Set(favoritesApi.favorites);
            const arr=data.filter((w)=>ids.has(w.id));
            return arr.length?arr:data;
          }
          return data;
        }, [source, favoritesApi.favorites, data]);
        const [idx, setIdx] = useState(0); const [score, setScore] = useState(0);
        const [input, setInput] = useState(""); const [showAns, setShowAns] = useState(false);
        const item = pool[idx % pool.length];
        const sentence = item.example_sentence || exampleFor(item.english_word, (item.posTags||[])[0]);
        const cloze = makeCloze(sentence, item.english_word);
        const trySubmit = () => { const ok = input.trim().toLowerCase() === item.english_word.toLowerCase(); if (ok) setScore(s=>s+1); setShowAns(true); };
        const next = () => { setIdx(i=>i+1); setInput(""); setShowAns(false); };
        return (
          <div>
            <div className="flex items-center justify-between mb-2">
              <h1 className="text-2xl font-bold">填空測驗</h1>
              <div className="text-sm text-gray-600">來源：{source === 'favorites'? '我的最愛':'全部單字'}</div>
            </div>
            <div className="rounded-2xl border p-5">
              <div className="text-gray-500 text-sm mb-2">第 {idx+1} 題／{pool.length}｜分數 {score}</div>
              <p className="text-lg mb-4">{cloze}</p>
              <input value={input} onChange={(e)=>setInput(e.target.value)} placeholder="輸入答案" className="w-full md:w-1/2 px-4 py-2 rounded-xl border border-gray-300 focus:outline-none focus:ring-2 focus:ring-indigo-500" />
              <div className="mt-3 flex gap-2">
                <Button onClick={trySubmit}>提交</Button>
                <Button variant="ghost" onClick={()=>setShowAns(s=>!s)}>{showAns?"隱藏答案":"提示/答案"}</Button>
                <Button variant="ghost" onClick={next}>下一題</Button>
              </div>
              {showAns && (
                <div className="mt-3 text-sm">
                  <div>正確答案：<span className="font-semibold">{item.english_word}</span></div>
                  <div className="text-gray-600">提示（詞性）：{(item.posTags||[]).join(', ')}</div>
                  <div className="text-gray-600">中文：{item.example_translation || translationFor(item.english_word, (item.posTags||[])[0])}</div>
                </div>
              )}
            </div>
          </div>
        );
      };

      const SelfTests = ({ data }) => {
        const [open, setOpen] = useState(false);
        const results = useMemo(() => {
          const r = [];
          const rows1 = parseCSV('英文,中譯\n"a,b",好\n'); r.push({name:'CSV quoted comma (LF)', pass: rows1.length===1 && (rows1[0].英文==='a,b' || rows1[0]['a,b']==='好')});
          const rows2 = parseCSV('英文,中譯\r\n"a,b",好\r\n'); r.push({name:'CSV quoted comma (CRLF)', pass: rows2.length===1});
          const after = data.find((w)=>w.english_word.toLowerCase()==='after'); r.push({name:'Multi-POS seed union', pass: !!(after && after.posTags.includes('preposition') && after.posTags.includes('conjunction'))});
          const c1 = makeCloze('They add values.', 'add'); r.push({name:'Cloze basic', pass: /_____/.test(c1)});
          const c2 = makeCloze('C++ is powerful.', 'C++'); r.push({name:'Cloze escapes symbols', pass: /_____/.test(c2)});
          r.push({name:'POS normalize pronoun', pass: normalizePOS('代名詞')==='pronoun'});
          r.push({name:'POS normalize adv.', pass: normalizePOS('adv.')==='adverb'});
          const ms = multiSplit('a，b\nc'); r.push({name:'multiSplit Chinese & LF', pass: ms.length===3 && ms[0]==='a' && ms[1]==='b' && ms[2]==='c'});
          const g1 = grammarDefaults('we','pronoun','主格代名詞'); r.push({name:'Grammar default pronoun subj.', pass: /主詞/.test(g1.grammar_function) && /we/.test(g1.sentence_pattern)});
          const g2 = grammarDefaults('always','adverb',''); r.push({name:'Grammar default adverb frequency', pass: /頻率/.test(g2.grammar_function)});
          const t1 = translationFor('activity','noun'); r.push({name:'translation default noun', pass: /^這是/.test(t1)});
          const t2 = translationFor('add','verb'); r.push({name:'translation default verb', pass: /(每天add。|每天加。)$/.test(t2)});
          return r;
        }, [data]);
        const passCount = results.filter(x=>x.pass).length;
        return (
          <div className="mt-6">
            <button className="text-xs text-indigo-600 underline" onClick={()=>setOpen(o=>!o)}>{open?"隱藏開發測試":"顯示開發測試"}（{passCount}/{results.length} 通過）</button>
            {open && (<ul className="text-xs text-gray-600 list-disc pl-5 mt-2">{results.map((t,i)=>(<li key={i}>{t.name}: {t.pass?"PASS":"FAIL"}</li>))}</ul>)}
          </div>
        );
      };

      function App(){
        const { hash, push } = useHashRoute();
        const favoritesApi = useFavorites();
        const userExamplesApi = useUserExamples();
        const { data, addItems, reset } = useDataset();
        const [route, param] = useMemo(() => {
          const h=hash.replace(/^#\//, "");
          if(!h) return ["home", null];
          const [p0,p1]=h.split("?")[0].split("/");
          if(p0==="") return ["home", null];
          if(p0==="category") return ["category", p1];
          if(p0==="word") return ["word", p1];
          if(p0==="favorites") return ["favorites", null];
          if(p0==="quiz") return ["quiz", null];
          return ["home", null];
        }, [hash]);
        const [navHistory, setNavHistory] = useState(() => ({ current: { route, param }, previous: null }));
        useEffect(() => {
          setNavHistory(prev => {
            if (prev.current.route === route && prev.current.param === param) return prev;
            return { current: { route, param }, previous: prev.current };
          });
        }, [route, param]);
        return (
          <Shell onReset={reset}>
            {route === "home" && <><Home push={push} data={data} onImport={addItems} /><SelfTests data={data} /></>}
            {route === "category" && <CategoryList cat={param} data={data} />}
            {route === "word" && <WordDetail id={param} data={data} favoritesApi={favoritesApi} userExamplesApi={userExamplesApi} push={push} prevRoute={navHistory.previous} />}
            {route === "favorites" && <FavoritesPage favoritesApi={favoritesApi} data={data} />}
            {route === "quiz" && <QuizPage favoritesApi={favoritesApi} hash={hash} data={data} />}
          </Shell>
        );
      }

      const rootEl = document.getElementById('root');
      if (rootEl) {
        ReactDOM.createRoot(rootEl).render(<App />);
      }
    </script>
  </body>
</html>
